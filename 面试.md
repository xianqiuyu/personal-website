## 小红书前端面经整理

> 根据“小红书前端面经”截图整理，分为一面 / 二面两部分，适合复习与扩展练习。

---

## 一面题目

### 1. 实现数组扁平化的多种方法

假设示例数组：

```js
const arr = [1, [2, [3, 4], 5]]
```

#### 方法一：递归 + `reduce`

```js
function flatDeep(arr) {
  return arr.reduce((res, item) => {
    return res.concat(Array.isArray(item) ? flatDeep(item) : item)
  }, [])
}

flatDeep(arr) // [1, 2, 3, 4, 5]
```

#### 方法二：`Array.prototype.flat`

```js
arr.flat(Infinity)
```

#### 方法三：迭代 + 栈

```js
function flatIterative(arr) {
  const stack = [...arr]
  const res = []

  while (stack.length) {
    const item = stack.pop()
    if (Array.isArray(item)) {
      stack.push(...item)
    } else {
      res.push(item)
    }
  }

  return res.reverse()
}

flatIterative(arr) // [1, 2, 3, 4, 5]
```

> **扩展追问**
>
> - 如何控制扁平化的层级（例如只拍平一层、两层）？
> - 扁平化同时去重、排序应该怎么组合实现？

---

### 2. 解释闭包及其常见应用场景

- **概念**：函数 A 内部返回函数 B，且 B 使用了 A 中的变量；即使 A 执行结束，这些变量依然被 B“记住”，这就是闭包。
- **作用**：
  - 延长外部函数变量的生命周期。
  - 实现“私有变量”、封装状态。

#### 示例：计数器

```js
function createCounter() {
  let count = 0
  return function () {
    count++
    return count
  }
}

const counter = createCounter()
counter() // 1
counter() // 2
```

#### 常见应用场景

- **封装私有状态**：计数器、缓存、模块内部变量等。
- **函数工厂**：根据不同配置生成不同的处理函数。
- **柯里化、高阶函数**：如防抖、防抖/节流函数内部保存定时器 id。
- **循环中保存索引**（早期配合 `var` 解决闭包问题）。

> **扩展追问**
>
> - 闭包会带来哪些内存问题？如何避免不必要的闭包？
> - 在实际项目里，你在哪些地方主动利用了闭包？

---

### 3. CSS 选择器优先级计算规则

记忆顺序：**行内 > ID > 类 / 属性 / 伪类 > 标签 / 伪元素**。

可以抽象为一个四元组 \((a, b, c, d)\)：

- **a**：是否使用 `!important`（严格来说它是单独一层，比所有普通优先级都高）。
- **b**：行内样式（如 `<div style="...">`）。
- **c**：`id` 选择器数量（`#app`）。
- **d**：类、属性、伪类选择器数量（`.item`、`[type="text"]`、`:hover` 等）。
- **e**：标签、伪元素选择器数量（`div`、`::before` 等）。

例子：

- `#app .item.active span` → (0, 1, 2, 1)
- `.item:hover` → (0, 0, 2, 0)

计算时：**从左到右逐位比较，数值大的优先；相同则后写的覆盖先写的**。

注意：

- 组合符（`>`、`+`、`~`、空格）和通配符 `*` **不增加优先级**。
- `!important` 只改变声明的权重，不改变选择器本身的结构。

> **扩展追问**
>
> - 如何在不依赖 `!important` 的前提下调整样式覆盖关系？
> - CSS-in-JS / CSS Modules 对优先级有什么影响？

---

### 4. 手写 `Promise.all`

**需求**：

- 所有 Promise 都成功时，按原顺序返回结果数组。
- 任意一个 Promise 失败，整体立即 `reject`。
- 入参可以是类数组 / iterable，元素可不是 Promise（需要用 `Promise.resolve` 包装）。

```js
function myPromiseAll(iterable) {
  return new Promise((resolve, reject) => {
    const arr = Array.from(iterable)
    const len = arr.length

    if (len === 0) {
      resolve([])
      return
    }

    const results = new Array(len)
    let finished = 0

    arr.forEach((item, index) => {
      Promise.resolve(item).then(
        value => {
          results[index] = value
          finished++
          if (finished === len) {
            resolve(results)
          }
        },
        error => {
          reject(error)
        }
      )
    })
  })
}
```

> **扩展追问**
>
> - `Promise.all` 与 `Promise.allSettled` 的区别？
> - 如何实现限流版本的 `Promise.all`（如同时只跑 N 个任务）？

---

### 5. 解释浏览器事件循环机制

JavaScript 是单线程，依赖 **事件循环（Event Loop）** 协调任务执行：

- **调用栈**：执行同步代码。
- **任务队列**：
  - **宏任务（macrotask）**：`setTimeout`、`setInterval`、I/O、UI 事件等。
  - **微任务（microtask）**：`Promise.then/catch/finally`、`queueMicrotask`、`MutationObserver` 等。

#### 一轮事件循环的大致流程

1. 从宏任务队列中取出一个宏任务，压入调用栈执行（这一步会执行完所有同步代码）。
2. 执行结束后，依次执行在这期间产生的所有 **微任务队列**。
3. 如需要，则进行一次 UI 渲染。
4. 再从宏任务队列取下一个宏任务，重复上述过程。

因此：

- **微任务优先于下一次宏任务执行**。
- 多个 `Promise.then` 注册的回调会在当前宏任务结束后、下一个 `setTimeout` 宏任务执行前统一执行。

> **扩展追问**
>
> - Node.js 的事件循环阶段有哪些，与浏览器有何不同？
> - `async/await` 在事件循环中是如何调度的？

---

## 二面题目

### 1. 虚拟 DOM diff 算法具体实现原理

目的：**在保持 UI 正确的前提下，尽量减少、不重复 DOM 操作**。

核心策略：

- **同级比较，不跨层级**：只比较同一层的子节点，不轻易做移动层级这样的昂贵操作。
- **通过 `key` 做可复用节点匹配**，只更新有变化的部分。
- **分层 diff**：
  - **Tree diff**：只比较当前层的子节点。
  - **Component diff**：组件类型相同则复用实例、更新 props；类型不同则卸载重建。
  - **Element diff**：标签名相同则复用 DOM，只更新属性、事件、子节点；不同则销毁重建。

现代框架（React/Vue）中的常见优化：

- 使用 **双端指针**（头尾比较）来快速处理列表首尾插入删除。
- 使用 **最长递增子序列（LIS）** 来最小化移动操作次数。
- 合并多次 DOM 操作，最后统一 patch。

> **扩展追问**
>
> - 为什么不直接对真实 DOM 做 diff，而要引入虚拟 DOM？
> - 什么时候应该给列表元素添加 `key`，`key` 选什么合适？

---

### 2. 前端性能优化方案（至少 5 种）

从不同维度总结一些常见手段：

#### 构建与资源层

- **代码分割、按需加载**：路由懒加载、组件懒加载，减少首屏 JS 体积。
- **Tree-shaking、移除 dead code**。
- 压缩、混淆 JS/CSS，启用 Gzip / Brotli。

#### 网络与缓存

- 利用 **HTTP 缓存**（`Cache-Control`、`ETag`），合理设置过期时间。
- 静态资源使用 **CDN 加速**。
- 预加载 / 预获取：`<link rel="preload">`、`<link rel="prefetch">`。

#### 页面渲染与运行时

- 减少重排与重绘：合并 DOM 操作；避免在高频场景频繁读取回流属性。
- 长列表使用 **虚拟列表（virtual list）**。
- 滚动、resize 等高频事件使用 **防抖 / 节流**。

#### 图片与媒体

- 图片压缩、使用合适格式（WebP、AVIF）。
- 按需加载（懒加载）：`<img loading="lazy">` 或 IntersectionObserver。

> **扩展追问**
>
> - 如何量化性能优化效果（Performance、Lighthouse、Web Vitals 等）？
> - SPA 的首屏渲染和白屏问题如何优化（SSR、预渲染、骨架屏）？

---

### 3. 实现函数柯里化的两种方式

**柯里化**：将一个接受多个参数的函数，转化为多个只接受一个或部分参数的函数，并返回新的函数。

#### 实现一：通用递归柯里化

```js
function curry(fn, ...args) {
  if (args.length >= fn.length) {
    return fn(...args)
  }
  return (...rest) => curry(fn, ...args, ...rest)
}

function add(a, b, c) {
  return a + b + c
}

const curriedAdd = curry(add)
curriedAdd(1)(2)(3)   // 6
curriedAdd(1, 2)(3)   // 6
curriedAdd(1)(2, 3)   // 6
```

#### 实现二：基于 `bind` 的简化实现

```js
function curryByBind(fn, ...args) {
  if (args.length >= fn.length) {
    return fn(...args)
  }
  return curryByBind.bind(null, fn, ...args)
}
```

> **扩展追问**
>
> - 柯里化在实际业务中有什么典型应用场景？
> - 柯里化与偏函数（partial）有什么区别？

---

### 4. 解释 HTTP/2 新特性

相较于 HTTP/1.1，HTTP/2 主要有以下新特性：

- **二进制分帧**：采用二进制格式的帧（frame），而非文本报文，方便解析和扩展。
- **多路复用（Multiplexing）**：一个 TCP 连接上并发多个请求 / 响应 stream，避免队头阻塞。
- **头部压缩（HPACK）**：对重复的 Header 使用静态 / 动态字典压缩，减少带宽。
- **服务器推送（Server Push）**：服务端可主动向客户端推送资源（如 CSS / JS），减少 RTT。
- **请求优先级**：客户端可指定流的优先级，服务端可按权重调度。

> **扩展追问**
>
> - HTTP/3 又解决了 HTTP/2 的哪些问题（基于 QUIC、0-RTT、内建多路复用等）？
> - 在前端实践中如何利用 HTTP/2 的优势（如合并请求策略的调整）？

---

### 5. React Fiber 架构设计思想

**背景问题**：旧版 React 使用递归遍历虚拟 DOM，一次更新过程不可中断。当组件树很大或更新复杂时，会长时间占用主线程，导致页面卡顿、掉帧。

**Fiber 的核心思想**：

- 使用 **Fiber 节点** 作为虚拟的“工作单元”，类似一个个轻量级的调用栈帧。
- 将渲染工作拆分成许多小任务，配合调度器，在空闲时间（`requestIdleCallback` 思想）执行，**可中断、可恢复**。
- 将更新过程拆分为两个阶段：
  - **Render（Reconciliation）阶段**：计算变更、构建新的 Fiber 树，可被打断。
  - **Commit 阶段**：将变更一次性提交到 DOM，不可打断，但时间很短。

带来的能力：

- 支持 **优先级更新**：如用户输入、动画的优先级高于低优先级的渲染。
- 支持 **并发模式（Concurrent Mode）**、`Suspense`、时间切片等高级特性。

> **扩展追问**
>
> - Fiber 与传统递归调用栈相比，在内存与复杂度上的权衡？
> - Concurrent Mode 中 `useTransition`、`Suspense` 的工作原理大致是什么？

---

### 6. Webpack 热更新（HMR）原理

**目标**：在不刷新整个页面的前提下，替换更新过的模块代码，同时尽量保留应用运行状态。

基本流程：

1. 开发模式下，Webpack 启动 dev server，并在页面注入 **HMR runtime**。
2. 源码变动 → Webpack 重新编译生成新的模块及 hash。
3. 通过 **WebSocket** 将更新信息（hash、模块 id 等）推送给浏览器。
4. 浏览器端的 HMR runtime：
   - 请求最新的代码片段（通常通过 `jsonp` / `fetch`）。
   - 判断哪些模块可热替换（根据 `module.hot.accept` 等 API）。
   - 在内存中替换对应模块的实现，并重新执行，而无需整页刷新。
5. 如果替换失败或模块不支持 HMR，则回退为整页刷新。

> **扩展追问**
>
> - Vite / Snowpack 的热更新机制与 Webpack 有何不同？
> - 在 React/Vue 项目中，哪些代码更新更适合通过 HMR，而不是刷新页面？

---

### 7. 如何实现 0.5px 边框

在高分屏（devicePixelRatio ≥ 2）下，1 CSS 像素对应 2 个物理像素，可以通过多种方式实现“视觉上的 0.5px 边框”：

#### 方案一：缩放 `scale`（通用）

```css
.border-hairline {
  position: relative;
}

.border-hairline::after {
  content: '';
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  border-top: 1px solid #ddd;
  transform: scaleY(0.5);
  transform-origin: 0 0;
}
```

#### 方案二：直接使用 `0.5px`（部分浏览器已支持）

```css
@media (-webkit-min-device-pixel-ratio: 2) {
  .hairline {
    border-bottom: 0.5px solid #ddd;
  }
}
```

#### 方案三：`box-shadow` / 渐变背景模拟边线

```css
.hairline-shadow {
  box-shadow: 0 0.5px 0 #ddd;
}
```

> **扩展追问**
>
> - 在不同 DPR 的设备上如何统一视觉效果？
> - 0.5px 边框在滚动、缩放时是否会出现锯齿或对齐问题？

---

> 建议使用方式：
>
> - 每道题先尝试自己回答，再对照本笔记进行补充与纠正。
> - 根据“扩展追问”准备对应的延伸答案，面试时更容易展开深入交流。

